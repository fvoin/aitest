<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Gecko Slide: Long & Dangerous</title>
    <style>
        :root {
            --bg-color: #212121;
            --panel-color: #333;
            --text-color: #eee;
            --accent: #00e676;
            --danger: #ff5252;
            --warn: #ffea00;
        }
        body {
            margin: 0; overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, sans-serif;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            height: 100vh; touch-action: none;
        }
        #ui-top {
            width: 100%; max-width: 600px;
            display: flex; justify-content: space-between;
            padding: 10px 20px; box-sizing: border-box;
            font-size: 20px; font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        #timer-bar-bg {
            width: 100%; max-width: 600px; height: 6px;
            background: #444; margin-bottom: 10px;
            border-radius: 3px; overflow: hidden;
        }
        #timer-bar-fill {
            height: 100%; width: 100%; background: var(--accent);
            transition: width 0.2s linear;
        }
        canvas {
            background-color: #263238;
            border-radius: 12px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.5);
            max-width: 96vw; max-height: 80vh;
        }
        #modal {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 20; display: none; text-align: center;
        }
        h1 { font-size: 2.5rem; color: var(--accent); margin: 0 0 10px 0; }
        h2 { font-size: 1.5rem; color: #fff; margin: 0 0 20px 0; }
        p { font-size: 1.1rem; color: #bbb; max-width: 400px; margin-bottom: 30px; line-height: 1.5;}
        button {
            padding: 15px 40px; font-size: 1.2rem;
            background: linear-gradient(to bottom, #00e676, #00c853);
            border: none; border-radius: 50px;
            cursor: pointer; font-weight: bold; color: #003300;
            box-shadow: 0 5px 15px rgba(0,230,118,0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active { transform: scale(0.95); box-shadow: 0 2px 5px rgba(0,230,118,0.4); }
        .stars { font-size: 3rem; color: #ffd700; margin-bottom: 20px; letter-spacing: 5px; }
        .mechanic-badge {
            background: #444; color: #fff; padding: 5px 15px;
            border-radius: 20px; font-size: 0.9rem; margin-top: 10px;
            border: 1px solid #666;
        }
    </style>
</head>
<body>

    <div id="ui-top">
        <div id="level-display">Level 1</div>
        <div id="mechanic-display" style="font-size: 0.8em; color: #aaa;">Basic</div>
    </div>
    <div id="timer-bar-bg"><div id="timer-bar-fill"></div></div>

    <canvas id="gameCanvas"></canvas>

    <div id="modal">
        <h1 id="modal-title">Super Gecko Slide</h1>
        <h2 id="modal-sub"></h2>
        <div class="stars" id="modal-stars"></div>
        <p id="modal-msg">Drag geckos by Head or Tail.<br>Collect Keys to unlock Holes!</p>
        <button id="modal-btn">Play</button>
        <div id="new-mech-badge" class="mechanic-badge" style="display:none">New Mechanic!</div>
    </div>

<script>
/**
 * CONFIG & ASSETS
 */
const COLORS = {
    red:    { main: '#FF5252', dark: '#C62828', hole: '#FFCDD2' },
    green:  { main: '#69F0AE', dark: '#2E7D32', hole: '#C8E6C9' },
    blue:   { main: '#448AFF', dark: '#1565C0', hole: '#BBDEFB' },
    yellow: { main: '#FFD740', dark: '#FF8F00', hole: '#FFF9C4' },
    purple: { main: '#E040FB', dark: '#7B1FA2', hole: '#E1BEE7' },
    orange: { main: '#FFAB40', dark: '#EF6C00', hole: '#FFE0B2' },
    wall:   '#546E7A',
    empty:  '#263238',
    lockIcon: '#212121'
};

const IS_SAME = (a, b) => a.x === b.x && a.y === b.y;

/**
 * LEVEL DATA
 */
const mkGecko = (id, color, coords, target) => ({ id, color, segments: coords, target });

const LEVELS = [
    // --- 1-5: BASICS ---
    {
        id: 1, title: "Warm Up", grid: 5, time: 30, msg: "Drag the Head or Tail.",
        geckos: [ mkGecko(1, 'green', [{x:1,y:2},{x:0,y:2}], {x:4,y:2}) ]
    },
    {
        id: 2, title: "Blocked Path", grid: 5, time: 35,
        geckos: [
            mkGecko(1, 'blue', [{x:0,y:2},{x:0,y:3}], {x:4,y:2}),
            mkGecko(2, 'red', [{x:2,y:1},{x:2,y:2}], {x:2,y:4})
        ]
    },
    {
        id: 3, title: "Reverse Gear", grid: 5, time: 40, msg: "Drag tail to back up!",
        walls: [{x:3,y:2}],
        geckos: [ mkGecko(1, 'yellow', [{x:3,y:1},{x:2,y:1},{x:2,y:2}], {x:4,y:2}) ]
    },
    {
        id: 4, title: "Tight Corners", grid: 6, time: 45,
        walls: [{x:2,y:2}, {x:2,y:3}],
        geckos: [ mkGecko(1, 'purple', [{x:0,y:2},{x:1,y:2},{x:1,y:3}], {x:4,y:2}) ]
    },
    {
        id: 5, title: "Traffic Control", grid: 6, time: 50,
        geckos: [
            mkGecko(1, 'red', [{x:1,y:2},{x:0,y:2}], {x:5,y:2}),
            mkGecko(2, 'green', [{x:3,y:0},{x:3,y:1}], {x:3,y:5}),
            mkGecko(3, 'blue', [{x:4,y:4},{x:5,y:4}], {x:0,y:4})
        ]
    },

    // --- 6-10: KEYS ---
    {
        id: 6, title: "Locked Door", grid: 5, time: 45, mechanic: "Keys Unlock Holes",
        keys: [{x:0,y:4, color:'red'}],
        walls: [{x:2,y:2}],
        geckos: [ mkGecko(1, 'red', [{x:0,y:0},{x:1,y:0}], {x:4,y:2}) ]
    },
    {
        id: 7, title: "Helper", grid: 5, time: 50,
        keys: [{x:0,y:0, color:'blue'}],
        geckos: [
            mkGecko(1, 'blue', [{x:2,y:2},{x:2,y:3}], {x:4,y:2}),
            mkGecko(2, 'green', [{x:4,y:0},{x:3,y:0}], {x:4,y:4})
        ]
    },
    {
        id: 8, title: "Detour", grid: 6, time: 50,
        keys: [{x:5,y:5, color:'yellow'}],
        walls: [{x:3,y:1},{x:3,y:2},{x:3,y:3}],
        geckos: [ mkGecko(1, 'yellow', [{x:0,y:2},{x:0,y:1}], {x:5,y:1}) ]
    },
    {
        id: 9, title: "Key Exchange", grid: 6, time: 60,
        keys: [{x:0,y:5, color:'green'}, {x:5,y:0, color:'red'}],
        geckos: [
            mkGecko(1, 'red', [{x:0,y:0},{x:1,y:0}], {x:0,y:2}),
            mkGecko(2, 'green', [{x:5,y:5},{x:4,y:5}], {x:5,y:3})
        ]
    },
    {
        id: 10, title: "Behind Bars", grid: 6, time: 60,
        walls: [{x:2,y:2},{x:3,y:2},{x:2,y:3},{x:3,y:3}],
        keys: [{x:0,y:3, color:'orange'}],
        geckos: [ mkGecko(1, 'orange', [{x:5,y:2},{x:5,y:1}], {x:5,y:5}) ]
    },

    // --- 11-15: INTERMEDIATE (Longer Geckos) ---
    {
        id: 11, title: "Long Winding Road", grid: 6, time: 50,
        walls: [{x:1,y:1},{x:3,y:1},{x:1,y:4},{x:3,y:4}],
        geckos: [ mkGecko(1, 'purple', [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:2,y:1}], {x:5,y:5}) ]
    },
    {
        id: 12, title: "The Hook", grid: 6, time: 55,
        keys: [{x:2,y:3, color:'red'}],
        walls: [{x:1,y:2},{x:2,y:2},{x:3,y:2},{x:1,y:3},{x:3,y:3},{x:1,y:4},{x:3,y:4}], // 2,4 is open
        geckos: [ mkGecko(1, 'red', [{x:0,y:0},{x:1,y:0},{x:2,y:0}], {x:5,y:2}) ]
    },
    {
        id: 13, title: "Synchronized", grid: 5, time: 60,
        keys: [{x:0,y:4, color:'blue'}],
        geckos: [
            mkGecko(1, 'blue', [{x:0,y:0},{x:1,y:0},{x:2,y:0}], {x:4,y:4}), // Length 3
            mkGecko(2, 'yellow', [{x:2,y:2},{x:2,y:1},{x:2,y:0}], {x:4,y:0}) 
        ]
    },
    {
        id: 14, title: "Corridor Jam", grid: 7, time: 70,
        walls: [{x:1,y:1},{x:1,y:2},{x:1,y:3},{x:1,y:4}, {x:5,y:1},{x:5,y:2},{x:5,y:3},{x:5,y:4}],
        geckos: [
            mkGecko(1, 'green', [{x:3,y:6},{x:3,y:5},{x:3,y:4},{x:3,y:3}], {x:3,y:0}), // Length 4
            mkGecko(2, 'red', [{x:2,y:0},{x:3,y:0},{x:4,y:0},{x:4,y:1}], {x:3,y:6}) // Length 4
        ]
    },
    {
        id: 15, title: "Key Blocker", grid: 6, time: 60,
        keys: [{x:0,y:5, color:'purple'}],
        geckos: [
            mkGecko(1, 'purple', [{x:0,y:0},{x:1,y:0},{x:2,y:0}], {x:5,y:0}), // Length 3
            mkGecko(2, 'orange', [{x:0,y:4},{x:1,y:4},{x:1,y:5}], {x:5,y:5})
        ]
    },

    // --- 16-20: HARDER LAYOUTS (Lengths 5-7) ---
    {
        id: 16, title: "Snake Charmer", grid: 8, time: 75,
        walls: [{x:3,y:1},{x:3,y:6}],
        geckos: [ mkGecko(1, 'blue', [{x:0,y:3},{x:1,y:3},{x:2,y:3},{x:3,y:3},{x:4,y:3},{x:5,y:3},{x:6,y:3}], {x:7,y:3}) ] // Length 7
    },
    {
        id: 17, title: "Double Lock", grid: 6, time: 70,
        keys: [{x:0,y:0, color:'red'}, {x:5,y:0, color:'blue'}],
        geckos: [
            mkGecko(1, 'red', [{x:1,y:5},{x:0,y:5},{x:0,y:4}], {x:5,y:5}),
            mkGecko(2, 'blue', [{x:4,y:5},{x:5,y:5},{x:5,y:4}], {x:0,y:5})
        ]
    },
    {
        id: 18, title: "The U-Turn", grid: 7, time: 70,
        walls: [{x:3,y:1},{x:3,y:2},{x:3,y:3},{x:3,y:4},{x:3,y:5}],
        keys: [{x:1,y:3, color:'green'}],
        geckos: [ mkGecko(1, 'green', [{x:5,y:1},{x:5,y:2},{x:5,y:3},{x:5,y:4},{x:5,y:5}], {x:1,y:1}) ] // Length 5
    },
    {
        id: 19, title: "Crowded House", grid: 6, time: 80,
        geckos: [
            mkGecko(1, 'red', [{x:0,y:0},{x:1,y:0},{x:2,y:0}], {x:5,y:5}),
            mkGecko(2, 'blue', [{x:5,y:0},{x:4,y:0},{x:3,y:0}], {x:0,y:5}),
            mkGecko(3, 'yellow', [{x:0,y:5},{x:1,y:5},{x:2,y:5}], {x:5,y:0}),
            mkGecko(4, 'green', [{x:5,y:5},{x:4,y:5},{x:3,y:5}], {x:0,y:0})
        ]
    },
    {
        id: 20, title: "Treasure Hunt", grid: 8, time: 90,
        keys: [{x:0,y:0, color:'purple'}, {x:7,y:7, color:'orange'}],
        walls: [{x:4,y:2},{x:4,y:3},{x:4,y:4},{x:4,y:5}],
        geckos: [
            mkGecko(1, 'purple', [{x:3,y:7},{x:2,y:7},{x:1,y:7},{x:0,y:7}], {x:3,y:0}), // Length 4
            mkGecko(2, 'orange', [{x:4,y:0},{x:5,y:0},{x:6,y:0},{x:7,y:0}], {x:4,y:7})  // Length 4
        ]
    },

    // --- 21-25: MOVING WALLS INTRO ---
    {
        id: 21, title: "Patrol Bot", grid: 6, time: 60, mechanic: "Moving Walls!",
        geckos: [ mkGecko(1, 'green', [{x:0,y:2},{x:0,y:3}], {x:5,y:2}) ],
        hazards: [
            { path: [{x:3,y:0}, {x:3,y:5}] } // Moves vertical in col 3
        ]
    },
    {
        id: 22, title: "Timing", grid: 6, time: 60,
        walls: [{x:2,y:2},{x:3,y:3}],
        geckos: [ mkGecko(1, 'red', [{x:0,y:0},{x:1,y:0},{x:2,y:0}], {x:5,y:5}) ],
        hazards: [
            { path: [{x:5,y:0}, {x:5,y:5}] }, // Blocks target approach
            { path: [{x:2,y:5}, {x:2,y:3}] }  // Small patrol
        ]
    },
    {
        id: 23, title: "Crusher", grid: 6, time: 50,
        keys: [{x:2,y:2, color:'blue'}],
        geckos: [ mkGecko(1, 'blue', [{x:0,y:2},{x:0,y:1}], {x:5,y:2}) ],
        hazards: [
            { path: [{x:2,y:0}, {x:2,y:5}] } // Patrols over the key
        ]
    },
    {
        id: 24, title: "The Gate", grid: 7, time: 70,
        walls: [{x:0,y:3},{x:1,y:3},{x:5,y:3},{x:6,y:3}], // Middle gap 
        geckos: [ mkGecko(1, 'orange', [{x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0}], {x:0,y:6}) ], // Length 4
        hazards: [
            { path: [{x:2,y:3}, {x:4,y:3}] } // Plugs the gap back and forth
        ]
    },
    {
        id: 25, title: "Double Jeopardy", grid: 8, time: 80,
        geckos: [ mkGecko(1, 'purple', [{x:0,y:3},{x:1,y:3},{x:2,y:3},{x:3,y:3}], {x:7,y:3}) ],
        hazards: [
            { path: [{x:4,y:0}, {x:4,y:7}] },
            { path: [{x:6,y:7}, {x:6,y:0}] } // Counter patrol
        ]
    },

    // --- 26-30: MASTER CLASS (Length 8-10) ---
    {
        id: 26, title: "Long Haul", grid: 9, time: 90,
        walls: [{x:4,y:0},{x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:5},{x:4,y:6},{x:4,y:7},{x:4,y:8}], 
        geckos: [ mkGecko(1, 'blue', [{x:0,y:4},{x:1,y:4},{x:2,y:4},{x:3,y:4},{x:3,y:3},{x:2,y:3},{x:1,y:3},{x:0,y:3}], {x:8,y:4}) ], // Length 8
        hazards: [ { path: [{x:4,y:4}, {x:5,y:4}] } ] // Patrols the only gap
    },
    {
        id: 27, title: "The Anaconda", grid: 10, time: 100,
        keys: [{x:9,y:0, color:'green'}],
        geckos: [
            mkGecko(1, 'green', [{x:0,y:9},{x:1,y:9},{x:2,y:9},{x:3,y:9},{x:4,y:9},{x:5,y:9},{x:6,y:9},{x:7,y:9},{x:8,y:9},{x:9,y:9}], {x:0,y:0}) // Length 10!!
        ],
        hazards: [ { path: [{x:5,y:0}, {x:5,y:8}] } ] // Vertical cut
    },
    {
        id: 28, title: "Slalom", grid: 9, time: 120,
        geckos: [ mkGecko(1, 'orange', [{x:0,y:0},{x:0,y:1},{x:0,y:2},{x:0,y:3},{x:0,y:4},{x:0,y:5}], {x:8,y:8}) ], // Length 6
        hazards: [
            { path: [{x:2,y:0}, {x:2,y:8}] },
            { path: [{x:4,y:8}, {x:4,y:0}] },
            { path: [{x:6,y:0}, {x:6,y:8}] }
        ]
    },
    {
        id: 29, title: "Locked Vault", grid: 7, time: 90,
        keys: [{x:3,y:3, color:'red'}],
        walls: [{x:2,y:2},{x:2,y:3},{x:2,y:4}, {x:4,y:2},{x:4,y:3},{x:4,y:4}],
        geckos: [ mkGecko(1, 'red', [{x:0,y:3},{x:1,y:3},{x:1,y:2},{x:1,y:1},{x:0,y:1}], {x:6,y:3}) ], // Length 5
        hazards: [ { path: [{x:3,y:2}, {x:3,y:4}] } ] // Inside the vault
    },
    {
        id: 30, title: "Grandmaster", grid: 10, time: 150, msg: "The Final Challenge",
        keys: [{x:0,y:0, color:'green'}, {x:9,y:9, color:'purple'}],
        walls: [{x:4,y:4},{x:5,y:4},{x:4,y:5},{x:5,y:5}], 
        geckos: [
            mkGecko(1, 'green', [{x:9,y:0},{x:8,y:0},{x:7,y:0},{x:6,y:0},{x:5,y:0},{x:5,y:1},{x:5,y:2}], {x:0,y:9}), // Length 7
            mkGecko(2, 'purple', [{x:0,y:9},{x:1,y:9},{x:2,y:9},{x:3,y:9},{x:4,y:9},{x:4,y:8},{x:4,y:7}], {x:9,y:0}) // Length 7
        ],
        hazards: [
            { path: [{x:0,y:5}, {x:9,y:5}] }, // Cross
            { path: [{x:5,y:0}, {x:5,y:9}] }
        ]
    }
];

/**
 * GAME LOGIC
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.levelIndex = 0;
        this.state = 'MENU'; 
        
        this.gridW = 6;
        this.tileSize = 0;
        this.walls = [];
        this.keys = [];
        this.geckos = [];
        this.holes = [];
        this.hazards = [];
        
        this.timeLeft = 0;
        this.maxTime = 0;
        
        this.dragStart = {x:0,y:0}; 
        this.selectedGecko = null;
        this.dragMode = null; 

        this.resize();
        window.addEventListener('resize', () => this.resize());
        this.bindInput();
        
        document.getElementById('modal-btn').onclick = () => {
            if (this.state === 'WON_ALL') this.levelIndex = 0;
            if (this.state === 'WON' || this.state === 'GAME_OVER') {
                 if(this.state === 'WON') this.levelIndex++;
            }
            this.startLevel(this.levelIndex);
        };

        this.showModal('Super Gecko Slide', 'Guide the geckos to their homes!', '', 'Start Game');
    }

    resize() {
        const maxW = window.innerWidth * 0.95;
        const maxH = window.innerHeight * 0.8;
        const size = Math.min(maxW, maxH);
        this.canvas.width = size;
        this.canvas.height = size;
        if(this.state === 'PLAYING') this.draw();
    }

    startLevel(idx) {
        if (idx >= LEVELS.length) {
            this.state = 'WON_ALL';
            this.showModal('Campaign Complete!', 'You are a Gecko Master!', '★★★★★', 'Play Again');
            return;
        }

        const data = LEVELS[idx];
        this.gridW = data.grid;
        this.tileSize = this.canvas.width / this.gridW;
        this.maxTime = data.time;
        this.timeLeft = data.time;
        
        this.walls = data.walls ? data.walls.map(w=>({...w})) : [];
        this.keys = data.keys ? data.keys.map(k=>({...k})) : [];
        this.geckos = JSON.parse(JSON.stringify(data.geckos));
        
        // Initialize Hazards (Moving Walls)
        this.hazards = [];
        if (data.hazards) {
            this.hazards = data.hazards.map(h => {
                const pts = [];
                const p = h.path;
                // Interpolate path
                for(let i=0; i<p.length-1; i++) {
                    let curr = p[i], next = p[i+1];
                    let dist = Math.abs(curr.x - next.x) + Math.abs(curr.y - next.y);
                    let dx = Math.sign(next.x - curr.x);
                    let dy = Math.sign(next.y - curr.y);
                    for(let k=0; k<dist; k++) {
                        pts.push({x: curr.x + dx*k, y: curr.y + dy*k});
                    }
                }
                pts.push(p[p.length-1]); 
                return { points: pts, idx: 0, dir: 1 };
            });
        }
        
        this.holes = this.geckos.map(g => ({...g.target, color: g.color}));

        document.getElementById('level-display').innerText = `Level ${idx+1}: ${data.title}`;
        document.getElementById('mechanic-display').innerText = data.mechanic || "";
        document.getElementById('modal').style.display = 'none';
        
        this.state = 'PLAYING';
        this.lastTime = performance.now();
        requestAnimationFrame(ts => this.loop(ts));
    }

    bindInput() {
        const getPointerPos = (e) => {
            const r = this.canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX - r.left, y: clientY - r.top };
        };

        const start = (e) => {
            if (this.state !== 'PLAYING') return;
            if (e.touches) e.preventDefault();
            
            const pos = getPointerPos(e);
            const gridPos = { 
                x: Math.floor(pos.x / this.tileSize), 
                y: Math.floor(pos.y / this.tileSize) 
            };
            
            for (let g of this.geckos) {
                if (IS_SAME(gridPos, g.segments[0])) {
                    this.selectedGecko = g; this.dragMode = 'head';
                    this.dragStart = pos; break;
                } else if (IS_SAME(gridPos, g.segments[g.segments.length-1])) {
                    this.selectedGecko = g; this.dragMode = 'tail';
                    this.dragStart = pos; break;
                }
            }
        };

        const move = (e) => {
            if (!this.selectedGecko) return;
            if (e.touches) e.preventDefault();
            
            const pos = getPointerPos(e);
            const dx = pos.x - this.dragStart.x;
            const dy = pos.y - this.dragStart.y;
            const THRESHOLD = this.tileSize; 

            if (Math.abs(dx) > THRESHOLD || Math.abs(dy) > THRESHOLD) {
                const dir = Math.abs(dx) > Math.abs(dy) ? {x:Math.sign(dx),y:0} : {x:0,y:Math.sign(dy)};
                
                const success = this.attemptMove(this.selectedGecko, this.dragMode, dir);
                
                if (success) {
                    this.dragStart = {
                        x: this.dragStart.x + (dir.x * THRESHOLD),
                        y: this.dragStart.y + (dir.y * THRESHOLD)
                    };
                    this.afterMove();
                }
            }
        };

        const end = () => { this.selectedGecko = null; };

        this.canvas.addEventListener('mousedown', start);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        this.canvas.addEventListener('touchstart', start, {passive:false});
        window.addEventListener('touchmove', move, {passive:false});
        window.addEventListener('touchend', end);
    }

    attemptMove(gecko, mode, dir) {
        const segs = gecko.segments;
        const head = segs[0];
        const tail = segs[segs.length-1];
        
        let currEnd = (mode === 'head') ? head : tail;
        let nextPos = { x: currEnd.x + dir.x, y: currEnd.y + dir.y };

        // Bounds & Walls
        if (nextPos.x < 0 || nextPos.x >= this.gridW || nextPos.y < 0 || nextPos.y >= this.gridW) return false;
        if (this.walls.some(w => IS_SAME(w, nextPos))) return false;
        
        // Hazards (Moving Walls) - Block movement if occupied
        if (this.hazards.some(h => IS_SAME(h.points[h.idx], nextPos))) return false;

        // Hole Interaction
        const hitHole = this.holes.find(h => IS_SAME(h, nextPos));
        if (hitHole) {
            if (hitHole.color === gecko.color) {
                const isLocked = this.keys.some(k => k.color === gecko.color);
                if (isLocked) return false; 
                this.geckoExit(gecko);
                return true;
            } else {
                return false; 
            }
        }

        // Body Logic
        let newSegs = [...segs];
        if (mode === 'head') {
            if (segs.length > 1 && IS_SAME(nextPos, segs[1])) return false; 
            newSegs.unshift(nextPos);
            newSegs.pop();
        } else {
            if (segs.length > 1 && IS_SAME(nextPos, segs[segs.length-2])) return false; 
            newSegs.push(nextPos);
            newSegs.shift();
        }

        // Collision with other Geckos
        for (let other of this.geckos) {
            if (other === gecko) continue;
            if (other.segments.some(s => IS_SAME(s, nextPos))) return false;
        }
        const isSelfCollide = newSegs.filter(s => IS_SAME(s, nextPos)).length > 1;
        if (isSelfCollide) return false;

        // Commit
        gecko.segments = newSegs;

        // Key Collection
        const newHead = gecko.segments[0];
        const keyIdx = this.keys.findIndex(k => IS_SAME(k, newHead));
        if (keyIdx !== -1) this.keys.splice(keyIdx, 1);
        
        return true;
    }

    afterMove() {
        // Update Hazards
        for (let h of this.hazards) {
            let nextIdx = h.idx + h.dir;
            if (nextIdx >= h.points.length) {
                nextIdx = h.points.length - 2; 
                h.dir = -1;
            } else if (nextIdx < 0) {
                nextIdx = 1;
                h.dir = 1;
            }
            h.idx = nextIdx;

            // Check CRUSH
            const wallPos = h.points[h.idx];
            for (let g of this.geckos) {
                if (g.segments.some(s => IS_SAME(s, wallPos))) {
                    this.crushGecko();
                    return;
                }
            }
        }
    }

    crushGecko() {
        this.state = 'GAME_OVER';
        this.showModal('Crushed!', 'Watch out for moving walls!', '☆☆☆', 'Try Again');
    }

    geckoExit(gecko) {
        this.geckos = this.geckos.filter(g => g !== gecko);
        this.holes = this.holes.filter(h => h.color !== gecko.color);
        this.selectedGecko = null;
        if (this.geckos.length === 0) this.winLevel();
    }

    winLevel() {
        this.state = 'WON';
        const pct = this.timeLeft / this.maxTime;
        let stars = 1;
        if (pct > 0.5) stars = 3;
        else if (pct > 0.2) stars = 2;
        const starStr = '★'.repeat(stars) + '☆'.repeat(3-stars);
        this.showModal('Level Complete!', 'Great Job!', starStr, 'Next Level');
    }

    gameOver() {
        this.state = 'GAME_OVER';
        this.showModal('Time Up!', 'The geckos are stuck!', '☆☆☆', 'Try Again');
    }

    showModal(title, sub, stars, btnTxt) {
        document.getElementById('modal').style.display = 'flex';
        document.getElementById('modal-title').innerText = title;
        document.getElementById('modal-sub').innerText = sub;
        document.getElementById('modal-stars').innerText = stars;
        document.getElementById('modal-btn').innerText = btnTxt;
        const badge = document.getElementById('new-mech-badge');
        badge.style.display = (LEVELS[this.levelIndex+1]?.mechanic) ? 'block' : 'none';
    }

    loop(ts) {
        if (this.state !== 'PLAYING') return;
        const dt = (ts - this.lastTime)/1000;
        this.lastTime = ts;
        
        this.timeLeft -= dt;
        if (this.timeLeft <= 0) { this.timeLeft = 0; this.gameOver(); }
        
        const pct = (this.timeLeft / this.maxTime) * 100;
        document.getElementById('timer-bar-fill').style.width = `${pct}%`;
        
        this.draw();
        requestAnimationFrame(t => this.loop(t));
    }

    draw() {
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        this.tileSize = this.canvas.width / this.gridW; 
        const TS = this.tileSize;
        const CTX = this.ctx;

        // Background
        CTX.fillStyle = COLORS.empty;
        CTX.fillRect(0,0,this.canvas.width, this.canvas.height);
        
        // Grid Lines
        CTX.strokeStyle = 'rgba(255,255,255,0.08)'; 
        CTX.lineWidth = 2;
        CTX.beginPath();
        for(let i=0; i<=this.gridW; i++) {
            CTX.moveTo(i*TS,0); CTX.lineTo(i*TS, this.canvas.height);
            CTX.moveTo(0,i*TS); CTX.lineTo(this.canvas.width, i*TS);
        }
        CTX.stroke();

        // Walls
        CTX.fillStyle = COLORS.wall;
        this.walls.forEach(w => this.drawRoundedRect(w.x, w.y, 0.9, 4));

        // Hazards (Moving Walls)
        this.hazards.forEach(h => {
            const pos = h.points[h.idx];
            // Hazard Stripes
            const x = pos.x*TS, y = pos.y*TS;
            CTX.fillStyle = '#546E7A'; 
            CTX.fillRect(x, y, TS, TS);
            CTX.fillStyle = 'rgba(255, 234, 0, 0.3)'; 
            CTX.fillRect(x, y, TS, TS);
            
            CTX.strokeStyle = '#FFEA00';
            CTX.lineWidth = 3;
            CTX.beginPath();
            CTX.moveTo(x, y); CTX.lineTo(x+TS, y+TS);
            CTX.moveTo(x+TS*0.5, y); CTX.lineTo(x+TS, y+TS*0.5);
            CTX.moveTo(x, y+TS*0.5); CTX.lineTo(x+TS*0.5, y+TS);
            CTX.stroke();
            CTX.strokeStyle = '#fff';
            CTX.lineWidth = 2;
            CTX.strokeRect(x,y,TS,TS);
        });

        // Keys
        this.keys.forEach(k => {
            CTX.fillStyle = COLORS[k.color].main;
            const cx = k.x*TS+TS/2, cy = k.y*TS+TS/2;
            CTX.beginPath(); CTX.arc(cx, cy-TS*0.1, TS*0.15, 0, Math.PI*2); CTX.fill();
            CTX.fillRect(cx-TS*0.05, cy, TS*0.1, TS*0.25);
            CTX.fillRect(cx, cy+TS*0.15, TS*0.1, TS*0.05);
        });

        // Holes
        this.holes.forEach(h => {
            CTX.fillStyle = COLORS[h.color].hole;
            CTX.beginPath();
            CTX.arc(h.x*TS + TS/2, h.y*TS + TS/2, TS*0.4, 0, Math.PI*2);
            CTX.fill();
            CTX.strokeStyle = COLORS[h.color].dark;
            CTX.lineWidth = 4;
            CTX.stroke();
            CTX.fillStyle = 'rgba(0,0,0,0.5)';
            CTX.beginPath(); CTX.arc(h.x*TS + TS/2, h.y*TS + TS/2, TS*0.25, 0, Math.PI*2); CTX.fill();

            if (this.keys.some(k => k.color === h.color)) {
                CTX.fillStyle = 'rgba(0,0,0,0.6)'; 
                CTX.beginPath(); CTX.arc(h.x*TS + TS/2, h.y*TS + TS/2, TS*0.4, 0, Math.PI*2); CTX.fill();
                
                const lx = h.x*TS + TS*0.35;
                const ly = h.y*TS + TS*0.35;
                CTX.fillStyle = '#fff';
                CTX.fillRect(lx, ly + TS*0.1, TS*0.3, TS*0.25);
                CTX.lineWidth = 3;
                CTX.strokeStyle = '#fff';
                CTX.beginPath();
                CTX.arc(lx + TS*0.15, ly + TS*0.1, TS*0.1, Math.PI, 0);
                CTX.stroke();
            }
        });

        // GECKOS
        this.geckos.forEach(g => {
            const c = COLORS[g.color];
            const segs = g.segments;

            CTX.strokeStyle = c.main;
            CTX.lineWidth = TS * 0.6;
            CTX.lineCap = 'round';
            CTX.lineJoin = 'round';
            CTX.beginPath();
            if (segs.length > 0) {
                CTX.moveTo(segs[0].x*TS + TS/2, segs[0].y*TS + TS/2);
                for(let i=1; i<segs.length; i++) {
                    CTX.lineTo(segs[i].x*TS + TS/2, segs[i].y*TS + TS/2);
                }
            }
            CTX.stroke();

            segs.forEach((s, i) => {
                const cx = s.x*TS + TS/2;
                const cy = s.y*TS + TS/2;
                const isHead = (i === 0);
                
                CTX.fillStyle = c.main;
                CTX.beginPath();
                let rad = isHead ? TS*0.32 : TS*0.28;
                CTX.arc(cx, cy, rad, 0, Math.PI*2);
                CTX.fill();

                CTX.fillStyle = 'rgba(255,255,255,0.2)';
                CTX.beginPath();
                CTX.arc(cx - rad*0.3, cy - rad*0.3, rad*0.4, 0, Math.PI*2);
                CTX.fill();

                if (isHead) {
                    CTX.fillStyle = 'white';
                    let dx = 0, dy = 1; 
                    if (segs.length > 1) {
                        dx = segs[0].x - segs[1].x;
                        dy = segs[0].y - segs[1].y;
                    }
                    const eyeOff = TS*0.15;
                    const eyeSize = TS*0.1;
                    
                    let ex1, ey1, ex2, ey2;
                    if (Math.abs(dx) > Math.abs(dy)) { 
                        ex1 = cx + dx*TS*0.1; ey1 = cy - eyeOff;
                        ex2 = cx + dx*TS*0.1; ey2 = cy + eyeOff;
                    } else { 
                        ex1 = cx - eyeOff; ey1 = cy + dy*TS*0.1;
                        ex2 = cx + eyeOff; ey2 = cy + dy*TS*0.1;
                    }

                    CTX.beginPath(); CTX.arc(ex1, ey1, eyeSize, 0, Math.PI*2); CTX.fill();
                    CTX.beginPath(); CTX.arc(ex2, ey2, eyeSize, 0, Math.PI*2); CTX.fill();
                    CTX.fillStyle = 'black';
                    CTX.beginPath(); CTX.arc(ex1, ey1, eyeSize*0.5, 0, Math.PI*2); CTX.fill();
                    CTX.beginPath(); CTX.arc(ex2, ey2, eyeSize*0.5, 0, Math.PI*2); CTX.fill();
                }
            });
        });
    }

    drawRoundedRect(x, y, scale, r) {
        const TS = this.tileSize;
        const pad = (1-scale)*TS/2;
        const X = x*TS+pad, Y = y*TS+pad, W = TS*scale, H = TS*scale;
        this.ctx.beginPath();
        this.ctx.roundRect(X, Y, W, H, r);
        this.ctx.fill();
    }
}

const game = new Game();

</script>
</body>
</html>